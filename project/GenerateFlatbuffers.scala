import sbt.Keys._
import sbt._

import scala.sys.process._

object GenerateFlatbuffers {

  lazy val task = Def.task {
    val flatcCmd = "flatc"
    val root     = baseDirectory.value
    val schemas =
      (file(s"$root/src/main/schema") ** "*.fbs").get
        .map(_.getAbsolutePath)
        .toList

    /*
    The flatc compiler can print Make rules for files it generates.
    We use this feature to easily get a list of files generated by this task.
    The printed rules have following format:
    ```
    file1.java \
    file2.java \
      ...
    fileN.java: \
    fileA.fbs \
    fileB.fbs \
      ...
    ```
     */
    def extractGeneratedFilenamesFromMakefile(
      makeRules: String
    ): Seq[String] = {
      val cleaned            = makeRules.replaceAllLiterally("\\", "");
      val Array(javaPart, _) = cleaned.split(':')

      val filenames = javaPart.split('\n').map(_.trim).filter(_.length > 0)
      filenames
    }

    val out = (sourceManaged in Compile).value
    val generatedFilenames = schemas flatMap { schema =>
        val cmd = s"$flatcCmd -M --java -o ${out.getAbsolutePath} $schema"
        println(s"*** Generating Java classes for schema: $schema, cmd: $cmd")
        val makeRules = cmd.!!
        println(
          s"*** Generated Java classes from FlatBuffer schema $schema."
        )

        extractGeneratedFilenamesFromMakefile(makeRules)
      }

    // The make rules include all affected files, so commonly used files can be present multiple times,
    // so we remove any duplicates.
    val uniqueFilenames      = generatedFilenames.distinct
    val uniqueGeneratedFiles = uniqueFilenames.map(file)

    println(
      f"*** Flatbuffers task generated ${uniqueGeneratedFiles.length} Java files in total."
    )
    uniqueGeneratedFiles
  }

}
